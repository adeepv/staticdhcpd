= Release errata =
== [http://www.rfc-archive.org/getrfc.php?rfc=4388 RFC4388] ==
The featureset described by this RFC, LEASEQUERY, is untested, yet has been included in versions 1.4.0+.

If you have an opportunity to try this out, please let us know if it works as expected. We have no means of testing it in a realistic environment and are therefore unwilling to declare it production-stable without real-world feedback.

In the event of any problems, no service will be disrupted -- the rest of the network will simply believe the DHCP server does not support this extension.
You'll just get e-mail about a problem with the server, which is what we need to see to get everything working right. So if you just enabled LEASEQUERY on a device in your network and things aren't going smoothly, go ahead and open an issue, pasting the stack trace as documentation -- we'll deal with it as soon as possible and work with you to get the bugs ironed out.

----
= Known issues =
There are no known issues at this time.

----
= Platform-specific questions =
== On Ubuntu, I get these "non-fatal select() error" messages in my logs at startup. Why? ==
Actually, we're not quite sure why, either. It seems as though Ubuntu's default configuration hits the process, when it starts, with a signal that generates an interrupt, which wakes the select() operations prematurely and causes them to throw an error because no handlers were invoked. No handlers were invoked because the nature of the interrupt is unknown, so to ensure normal operation, the error is semi-silently discarded and select() is invoked again, which is what would normally happen after each wakeup event. No requests can possibly be lost as a result of this error, so it's completely benign.

That said, if you see this message appear _after_ the initial startup, then you should start investigating the cause.

Further information:
 This is actually more of a Python issue than an Ubuntu issue (it would have been fixed if it were reasonably easy): Python's select() receives SIGINT, as it should, but there's no clear way to actually handle the signal gracefully -- although handling it properly would require knowledge of why it's actually being sent.

----
= Unsupported features =
 * [http://www.rfc-archive.org/getrfc.php?rfc=3011 RFC 3011] (Subnet selection)
  * This feature is not required in a purely static environment.
 * [http://www.rfc-archive.org/getrfc.php?rfc=3004 RFC 3004] (User class)
  * staticDHCPd requires that each client be known ahead of time, precuding any need for thenotion of dynamic assignment from pools based on clases.
 * [http://www.rfc-archive.org/getrfc.php?rfc=3118 RFC 3118] (DHCP Authentication)
  * This feature is not supported because of the large number of clients that ignore the option.
  * It is also unnecessary in any environment in which staticDHCPd should be used: if administrators do not have absolute control of their network, staticDHCPd is useless.
 * [http://www.rfc-archive.org/getrfc.php?rfc=3203 RFC 3203] (FORCERENEW)
  * This feature explicitly relies on RFC 3118
  * It also poses problems related to authority and shouldn't be necessary in an all-static environment.
  * It will be implemented if anyone makes a solid case for its inclusion, though.